---
layout: post
title:  "php11、12、13章"
date:   2016-01-15
categories: php
---


# 第三篇 应用篇
# 第十一章 文件系统与操作

## 目录操作
### 打开目录

```
语法：
resource opendir(string $path)
如果path不合法、权限限制或文件系统问题而不能打开目录，函数返回false，并且产生E_WARNING级别的错误信息，可以在函数前使用“@”符号抑制错误信息的输出。

一般是使用opendir时候会使用is_dir判断目录存在否
bool is_dir(string $filename)
```

```php
**检测打开**
<?php
$path = "/usr/local/apache/htdocs/php/ba";     //定义路径
if(is_dir($path)){          //判断目录是否存在
  $dir = @opendir($path) or die("不能打开" . $path . ".\n");      //如果无法打开则抛出错误信息
}else{
  echo $path . "不是合法目录路径.\n";
}
运行结果：
/usr/local/apache/htdocs/php/ba不是合法目录路径.
?>
```

### 关闭目录

```
打开目录后需要释放改目录资源
语法：
void closedir(resource $dir_handle)
$dir_handle为之前有opendir函数打开的目录返回的资源对象，改函数关闭由dir_handle所指定的目录资源对象，该资源对象之前必须被opendir打开。
```

```php
<?php
$path = "/usr/local/apache/htdocs/php/ba";        //定义打开目录
if(is_dir($path)){
  $dir = @opendir($path)  or die("不能打开" . $path . ".\n");
  closedir($dir);         //关闭目录
}else{
  echo $path . "不是合法目录路径.\n";
}
?>
```

### 读取目录

```
语法：
string readdir(resource $dir_handle)
参数$dir_handle是由opendir函数打开所返回的资源对象，该函数读取目录成功则返回目录下一个文件的文件名
```

```php
<?php
$path = "/usr/local/apache/htdocs/php/ba";
if(is_dir($path)){
  $dir = @opendir($path)  or die("不能打开" . $path . ".\n");
  while($file=readdir($dir)){
    echo $file . "\n";
  }
  closedir($dir);
}else{
  echo $path . "不是合法目录路径.\n";
}
?>
```

### 建立目录

```
bool mkdir(string $pathname[, int $mode])
pathname为要创建的目录名，mode为要创建的权限，权限是有八进制表示，该数以0开头，默认0777，函数创建成功返回bool类型true，否则返回false
```

```php
<?php
$path = "/usr/local/apache/htdocs/php/ba";
if(is_dir($path)){          //检测目录是否存在
  echo "目录：" . $path . "已存在.";
}else{
  if(mkdir($path,0777)){       //创建目录
    echo "目录：" . $path . "创建成功.\n";
  }else{
    echo "目录：" . $path . "创建失败.\n";
  }
}
```

### 删除目录

```
bool rmdir(string $dirname)
```

```php
<?php
$path = "test";
if(is_dir($path)){
  $hasDir = false;
  $dir = opendir($path);
  while($file=readdir($dir)){
    if($file <> '.' || $file <> '..'){
      $hasDir = true;
      break;
    }
  }
  closedir($dir);
  if($hasDir){
    if(rmdir($path))
    echo "目录：" . $path . "删除成功." . "\n";
    else
    echo "目录：" . $path . "删除失败" . "\n";
  }else
  echo "目录：" . $path  . "不为空，不能直接删除！";
}else {
  echo "目录" . $path .  "不是合法目录路径.\n";
}
```

### 改变目录

```
bool chdir(string $directory)

获取当前目录get_cwd
string getcwd(void)

如果改变目录成功返回当前工作目录，否则返回false
```

```php
<?php
if($path=getcwd()){
  echo "当前工作目录为："  . $path . ".\n";
  if(chdir("..")){
    echo "更改工作目录成功.\n";
    $path=getcwd();
    echo "当前工作目录为:" . $path . ".\n";
  }
}else {
  echo "获取当前目录失败.\n";
}
?>
运行结果：
当前工作目录为：/usr/local/apache/htdocs/php.
更改工作目录成功.
当前工作目录为:/usr/local/apache/htdocs.
```

## 文件操作

### 打开文件

```
语法：
resource fopen(string $filename, string $mode[, bool $use_include_path])
$filename 访问的文件名
$mode指定的访问类型
$use_include_path是否要从include_path中搜索文件
如果需要在include_path中搜索文件的话，可将use_include_path设置为1或true
为了便于程序移植，强烈建议在打开文件时总是使用“b”标记
```

|mode值|说明|
|---|---|
|r|以只读方式打开，将文件指针指向文件头|
|r+|读写方式打开，将文件指针指向文件头|
|w|写入方式打开，将文件指针指向文件头并将文件大小截为0，如果不存在就创建新文件|
|w+|读写方式打开，将文件指针指向文件头并将文件大小截为0，如果不存在就创建新文件|
|a|写入方式打开，将文件指针指向文件末尾，如果不存在就创建新文件|
|a+|读写方式打开，将文件指针指向文件末尾，如果不存在就创建新文件|
|x|创建并以写入方式打开，将文件指针指向文件头，如果文件已经存在，则fopen()调用失败并返回false，如果不存在就创建新文件|
|x+|创建并与读写方式打开，将文件指针指向文件头，如果文件已经存在，则fopen()调用失败并返回false|

```php
<?php
$file="/etc/test.txt";
$url="http://www.php.net";
if(($fh = fopen($file,'wb')) === false){      //b以二进制进行写入，防止乱码，更好的移植性
  die("采用写入方式打开文件：" . $file . "失败！\n");
}else{
  echo "采用写入方式打开文件:" . $file . "成功！\n";
}
if(($fn = fopen($url,'rb')) === false){
  die("采用只读方式读取失败:" . $url . "失败！\n");
}else{
  echo "采用只读方式读取:" .  $url . "成功! \n";
}
?>
运行结果：
采用写入方式打开文件:/etc/test.txt成功！
采用只读方式读取:http://www.php.net成功!
```

### 关闭文件

```
bool fclose(resource $handle)
$handle为打开文件资源对象，资源必须有效，且是通过fclose或fsockopen函数成功打开所返回的。函数关闭成功返回bool类型true，失败返回false
```

```php
<?php
$file = "test.txt";
if(($fh = fopen($file,'wb')) === false){
  die('采用写入方式打开文件：' .$file . '失败！\n');
}else{
  echo "采用写入方式打开文件：" .$file . "成功！\n";
}
if(fclose($fh))
  echo "文件：" . $file . "关闭成功\n";
else
  echo "文件：" . $file . "关闭失败\n";
if(($fn = fopen("http://www.baidu.com",'rb'))  === false){
  die("采用只读方式读取失败.\n");
}else{
  echo "采用只读方式成功.\n";
}
if(fclose($fn))
  echo "远程文件关闭成功\n";
else
  echo "远程文件关闭失败.\n";
?>
运行结果：
采用写入方式打开文件：test.txt成功！
文件：test.txt关闭成功
采用只读方式成功.
远程文件关闭成功
```

### 读取文件

```
string fgetc(resource $handle)
handle为要打开的文件资源，文件资源必须有效，必须指向一个由fopen函数或fsockopen函数打开且没有被关闭的文件资源。当碰到文件结束符EOF时返回false。
```

```php
<?php
$file = "test.txt";
if(($fh = fopen($file,'rb')) === false){
  die('采用只读方式打开文件：' . $file . '失败！\n');
}else{
  echo "采用只读方式打开" . $file . "成功\n";
}
if(($char = fgetc($fh)) === false)
  echo "读取文件：" . $file . "内容失败.\n";
else
  echo "读取文件：" . $file . "内容成功。读取内容为：" . $char . "\n";
if(fclose($fh))
  echo "文件：" . $file . "关闭成功\n";
else
  echo "文件：" . $file ."关闭失败.\n";
?>
运行结果：
采用只读方式打开test.txt成功
读取文件：test.txt内容成功。读取内容为：d
文件：test.txt关闭成功
```
