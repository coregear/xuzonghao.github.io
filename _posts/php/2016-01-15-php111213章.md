---
layout: post
title:  "php11、12、13章"
date:   2016-01-15
categories: php
---


# 第三篇 应用篇
# 第十一章 文件系统与操作

## 目录操作
### 打开目录

```
语法：
resource opendir(string $path)
如果path不合法、权限限制或文件系统问题而不能打开目录，函数返回false，并且产生E_WARNING级别的错误信息，可以在函数前使用“@”符号抑制错误信息的输出。

一般是使用opendir时候会使用is_dir判断目录存在否
bool is_dir(string $filename)
```

```php
**检测打开**
<?php
$path = "/usr/local/apache/htdocs/php/ba";     //定义路径
if(is_dir($path)){          //判断目录是否存在
  $dir = @opendir($path) or die("不能打开" . $path . ".\n");      //如果无法打开则抛出错误信息
}else{
  echo $path . "不是合法目录路径.\n";
}
运行结果：
/usr/local/apache/htdocs/php/ba不是合法目录路径.
?>
```

### 关闭目录

```
打开目录后需要释放改目录资源
语法：
void closedir(resource $dir_handle)
$dir_handle为之前有opendir函数打开的目录返回的资源对象，改函数关闭由dir_handle所指定的目录资源对象，该资源对象之前必须被opendir打开。
```

```php
<?php
$path = "/usr/local/apache/htdocs/php/ba";        //定义打开目录
if(is_dir($path)){
  $dir = @opendir($path)  or die("不能打开" . $path . ".\n");
  closedir($dir);         //关闭目录
}else{
  echo $path . "不是合法目录路径.\n";
}
?>
```

### 读取目录

```
语法：
string readdir(resource $dir_handle)
参数$dir_handle是由opendir函数打开所返回的资源对象，该函数读取目录成功则返回目录下一个文件的文件名
```

```php
<?php
$path = "/usr/local/apache/htdocs/php/ba";
if(is_dir($path)){
  $dir = @opendir($path)  or die("不能打开" . $path . ".\n");
  while($file=readdir($dir)){
    echo $file . "\n";
  }
  closedir($dir);
}else{
  echo $path . "不是合法目录路径.\n";
}
?>
```

### 建立目录

```
bool mkdir(string $pathname[, int $mode])
pathname为要创建的目录名，mode为要创建的权限，权限是有八进制表示，该数以0开头，默认0777，函数创建成功返回bool类型true，否则返回false
```

```php
<?php
$path = "/usr/local/apache/htdocs/php/ba";
if(is_dir($path)){          //检测目录是否存在
  echo "目录：" . $path . "已存在.";
}else{
  if(mkdir($path,0777)){       //创建目录
    echo "目录：" . $path . "创建成功.\n";
  }else{
    echo "目录：" . $path . "创建失败.\n";
  }
}
```

### 删除目录

```
bool rmdir(string $dirname)
```

```php
<?php
$path = "test";
if(is_dir($path)){
  $hasDir = false;
  $dir = opendir($path);
  while($file=readdir($dir)){
    if($file <> '.' || $file <> '..'){
      $hasDir = true;
      break;
    }
  }
  closedir($dir);
  if($hasDir){
    if(rmdir($path))
    echo "目录：" . $path . "删除成功." . "\n";
    else
    echo "目录：" . $path . "删除失败" . "\n";
  }else
  echo "目录：" . $path  . "不为空，不能直接删除！";
}else {
  echo "目录" . $path .  "不是合法目录路径.\n";
}
```

### 改变目录

```
bool chdir(string $directory)

获取当前目录get_cwd
string getcwd(void)

如果改变目录成功返回当前工作目录，否则返回false
```

```php
<?php
if($path=getcwd()){
  echo "当前工作目录为："  . $path . ".\n";
  if(chdir("..")){
    echo "更改工作目录成功.\n";
    $path=getcwd();
    echo "当前工作目录为:" . $path . ".\n";
  }
}else {
  echo "获取当前目录失败.\n";
}
?>
运行结果：
当前工作目录为：/usr/local/apache/htdocs/php.
更改工作目录成功.
当前工作目录为:/usr/local/apache/htdocs.
```

## 文件操作

### 打开文件

```
语法：
resource fopen(string $filename, string $mode[, bool $use_include_path])
$filename 访问的文件名
$mode指定的访问类型
$use_include_path是否要从include_path中搜索文件
如果需要在include_path中搜索文件的话，可将use_include_path设置为1或true
为了便于程序移植，强烈建议在打开文件时总是使用“b”标记
```

|mode值|说明|
|---|---|
|r|以只读方式打开，将文件指针指向文件头|
|r+|读写方式打开，将文件指针指向文件头|
|w|写入方式打开，将文件指针指向文件头并将文件大小截为0，如果不存在就创建新文件|
|w+|读写方式打开，将文件指针指向文件头并将文件大小截为0，如果不存在就创建新文件|
|a|写入方式打开，将文件指针指向文件末尾，如果不存在就创建新文件|
|a+|读写方式打开，将文件指针指向文件末尾，如果不存在就创建新文件|
|x|创建并以写入方式打开，将文件指针指向文件头，如果文件已经存在，则fopen()调用失败并返回false，如果不存在就创建新文件|
|x+|创建并与读写方式打开，将文件指针指向文件头，如果文件已经存在，则fopen()调用失败并返回false|

```php
<?php
$file="/etc/test.txt";
$url="http://www.php.net";
if(($fh = fopen($file,'wb')) === false){      //b以二进制进行写入，防止乱码，更好的移植性
  die("采用写入方式打开文件：" . $file . "失败！\n");
}else{
  echo "采用写入方式打开文件:" . $file . "成功！\n";
}
if(($fn = fopen($url,'rb')) === false){
  die("采用只读方式读取失败:" . $url . "失败！\n");
}else{
  echo "采用只读方式读取:" .  $url . "成功! \n";
}
?>
运行结果：
采用写入方式打开文件:/etc/test.txt成功！
采用只读方式读取:http://www.php.net成功!
```

### 关闭文件

```
bool fclose(resource $handle)
$handle为打开文件资源对象，资源必须有效，且是通过fclose或fsockopen函数成功打开所返回的。函数关闭成功返回bool类型true，失败返回false
```

```php
<?php
$file = "test.txt";
if(($fh = fopen($file,'wb')) === false){
  die('采用写入方式打开文件：' .$file . '失败！\n');
}else{
  echo "采用写入方式打开文件：" .$file . "成功！\n";
}
if(fclose($fh))
  echo "文件：" . $file . "关闭成功\n";
else
  echo "文件：" . $file . "关闭失败\n";
if(($fn = fopen("http://www.baidu.com",'rb'))  === false){
  die("采用只读方式读取失败.\n");
}else{
  echo "采用只读方式成功.\n";
}
if(fclose($fn))
  echo "远程文件关闭成功\n";
else
  echo "远程文件关闭失败.\n";
?>
运行结果：
采用写入方式打开文件：test.txt成功！
文件：test.txt关闭成功
采用只读方式成功.
远程文件关闭成功
```

### 读取文件

```
string fgetc(resource $handle)
handle为要打开的文件资源，文件资源必须有效，必须指向一个由fopen函数或fsockopen函数打开且没有被关闭的文件资源。当碰到文件结束符EOF时返回false。
```

```php
//采用fgetc函数读取指定文件中得一个字符
<?php
$file = "test.txt";
if(($fh = fopen($file,'rb')) === false){
  die('采用只读方式打开文件：' . $file . '失败！\n');
}else{
  echo "采用只读方式打开" . $file . "成功\n";
}
if(($char = fgetc($fh)) === false)
  echo "读取文件：" . $file . "内容失败.\n";
else
  echo "读取文件：" . $file . "内容成功。读取内容为：" . $char . "\n";
if(fclose($fh))
  echo "文件：" . $file . "关闭成功\n";
else
  echo "文件：" . $file ."关闭失败.\n";
?>
运行结果：
采用只读方式打开test.txt成功
读取文件：test.txt内容成功。读取内容为：d
文件：test.txt关闭成功
```

```php
//读取文件的一行
//采用fgets函数读取制定文件的一行
语法：
fgets(file,length)  length，可选。规定要读取的字节数。默认是 1024 字节。

<?php
$file = "test.txt";
$fh = @fopen($file,'rb');     //可以在语句前增加@符号进行特定行隐藏
if($fh){              //如果打开为true
  echo "从文件读取的内容为：\n";    
  while(!feof($fh)){        //判断文件是否结束，feof() 函数检测是否已到达文件末尾 (eof)。
    $buffer = fgets($fh,50);    //读取文件的一行
    echo $buffer;
  }
  fclose($fh);      //关闭文件
}
?>
运行结果：
q
q
w
e
```

```
按行读取的函数fgetss和fgetcsv函数，这两个函数在使用和fgets一样，区别在于fgetss函数将从取回的一行过滤HTML标记，儿fgetcsv函数则针对CSV文件取出其中一行，并直接返回包含这些字段的一个数。
```

```
//读取任意长度文件内容
string fread(int $handle, int $length)
handle为打开文件的资源对象
length为要读取内容的长度

<?php
$file = "test.txt";
$fh = @fopen($file,'rb');
if($fh){
  echo "从文件读取的内容为：\n";
  while(!feof($fh)){
    $content .= fread($fh,50);
  }
  echo $content;
  fclose($fh);
}
?>

file_get_contents函数把一个文件内容读取至一个字符串
```

### 写入文件

```
语法：
int fwrite(resource $handle, string $string[, int $length])
resource为打开文件时返回的资源对象
string为要写入文件的字符串
length为制定长度
写入成功返回写入的字符串的字节数，写入失败返回false
```

```php
<?php
$file = "test.txt";
$string = date("Y-m-j") . "写入文件测试. \n";       //写入时间
if(is_writable($file)){           //检测文件是否可写
  if(!$fh = fopen($file, "ab")){      //如果以ab模式打开$file文件失败，执行echo，否则返回$fh资源
    echo "不能打开文件：$file \n";
    exit;
  }
  if(fwrite($fh, $string) === false){     //将$string写入资源$fh，并根据返回值给出不同提示信息，写入成功返回字符串字节数，写入失败返回false
    echo "不能写入文件：$file \n";
    exit;
  }else{
    echo "写入文件：$file  成功. \n";
      }
  }else{
    echo "文件$file不可写. \n";
}
?>

返回结果：
qs
qsdsds
wsdfdf
es
2016-01-30写入文件测试.
2016-01-30写入文件测试.


以上程序也可以改成：
<?php
$file = "test.txt";
$string = date("Y-m-j") . "写入文件测试. \n";
if(is_writable($file)){           //检测文件是否可写
  if($f = fopen($file, "ab")){
    echo "打开文件：$file  ok\n";
    //exit;                                                                                                                                                             
  }
  if(fwrite($f, $string) === false){   //将$string写入资源$fh，并根据返回值给出不同提示信息，写入成功返回字符串字节数，写入失败返回false
    echo "写入文件：$file ok \n";
    exit;
  }else{
    echo "写入文件：$file  成功. \n";
      }   
  }else{
    echo "文件$file不可写. \n";
}
运行返回：
打开文件：test.txt  ok
写入文件：test.txt  成功.
```

### 删除文件

```
bool unlink(sting $filename)
filename为要删除的文件，删除成功返回true，删除失败返回false
```

```
<?php
$file = "test.txt";
if(unlink($file)){
  echo "文件：$file删除成功. \n";
}
else{
  echo "文件：$file 删除失败. \n";
}
?>
运行结果：
文件：test.txt 删除成功.
```

### 复制文件

```
bool copy(string $source, string $dest)
source为源文件名，dest为目标文件名，复制成功返回true，复制失败返回false
需要确认目标文件夹具有可写的权限
```

```php
定义和用法
realpath() 函数返回绝对路径。
该函数删除所有符号连接（比如 '/./', '/../' 以及多余的 '/'），返回绝对路径名。
若失败，则返回 false。比如说文件不存在的话。

<?php
$file = "test.txt";
$dir = basename(realpath($file));
echo realpath("test.txt") . "\n";
if(is_writable($dir)){
  if(copy($file,'tag.txt')){
    echo "文件：$file复制成功. \n";
  }
  else {
    echo "文件:$file 复制失败 . \n";
  }
}
else {
  echo "目录: $dir 不可写 . \n";
}
?>
运行结果：
/usr/local/apache/htdocs/php/test.txt
文件: test.txt 复制成功.
```

###　移动文件和重命名文件

```
bool rename(string $oldname, string $newname)
oldname源文件，newname为目标文件，成功返回true，失败返回false
技巧:源文件和目标文件路径相同，即可实现重命名；路径不同则实现移动文件
```

```php
<?php
$scrFile = "test.txt";
$tagFile_1 = "test.log";
$tagFile_2 = dirname(realpath($file)) . DIRECTORY_SEPARATOR . $scrFile;   //目标文件
if(rename($scrFile, $tagFile_1)){
  echo "文件：$file 重命名成功 . \n";
  if(rename($tagFile_1,$tagFile_2)){
    echo "文件：$tagFile_1 移动成功 . \n";
  }else{
    echo "文件：$tagFile_1 文件移动失败 . \n";
  }
}else{
    echo "文件：$scrFile 重命名失败 . \n";
}
?>

运行结果:
文件： 重命名成功 . 
文件：test.log 移动成功 
```

### 文件的上传与下载

配置php.ini
file_uploads  默认值1，开启文件上传
upload_tmp_dir  null ,上传文件到临时目录
upload_max_filesize 2M,允许上传文件大小

需要在HTML中加入file控件，指定表达enctype属性为multipart/from-data

```html
** 客户端上传文件 **
name:index.html

<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtm11/DTD/xhtm11-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>文件上传</title>
</head>
<body>
  <form method="post" action="11.17.php" enctype="multipart/form-data">     //multipart/form-data,不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。
    <input type="hidden" name="MAX_FILE_SIZE" value="30000" />          //MAX_FILE_SIZE必须放在file前，单位为字节
    请选择要上传的文件:
    <input type="file" id="upfile" name="upfile"/>
    <input type="submit" value="上传" id="submit"/>
  </form>
</body>
</html>
```

```php
name:11.17.php

<?php
header("Content-Type: text/html;charset=utf-8");        //规范为utf-8

$uploadpage = "index.html";
$dir = dirname(realpath(__FILE__)) . DIRECTORY_SEPARATOR;    //上传的文件目录
//die($dir);

$err_msg = false;
print_r($_FILES);       //测试

//判断表单是否存在
if(!isset($_FILES['upfile'])){          //$_FILES是上传文件变量数组，格式为Array ( [upfile] => Array ( [name] => 20160115_143317.jpg [type] => image/jpeg [tmp_name] => /tmp/phpIDoSXK [error] => 0 [size] => 3502037 ) ) 
  $err_msg = "表单不完全.请重新<a href='{$uploadpage}'>上传</a>\n";
}else{
  $fileImg = $_FILES['upfile'];
// print_r($fileImg);
}

//var_dump($maxUploadSize);
//echo ($fileImg['error']);
switch($fileImg['error']){
  case UPLOAD_ERR_INI_SIZE:
    $err_msg = "文件超过最大上传限制:$maxUploadSize . 请重新<a href='{$uploadpage}'>上传</a>\n";
    break;
  case UPLOAD_ERR_PARTIAL:
    $err_msg = "文件上传不完全.请重新<a href='{$uploadpage}'>上传</a>\n";
    break;
  case UPLOAD_ERR_NO_FILE:
    $err_msg = "没有选择文件.请重新<a href='{$uploadpage}'>上传</a>\n";
    break;
  case UPLOAD_ERR_FORM_SIZE:
    $err_msg = "文件超过最大上传限制.请重新<a href='{$uploadpage}'>上传</a>\n";
    break;
  case UPLOAD_ERR_CANT_WRITE:
    $err_msg = "文件写入失败.请重新<a href='{$uploadpage}'>上传</a>\n";
    break;
  case UPLOAD_ERR_NO_TMP_DIR:
    $err_msg = "没有临时文件夹.请重新<a href='{$uploadpage}'>上传</a>\n";
    break;
  case UPLOAD_ERR_OK:
    break;
  default:
    $err_msg = "未知错误.请重输<a href='{$uploadpage}'>上传</a>\n";
}
echo $err_msg;      //正常情况输出空


//判断上传文件格式
if(!in_array($fileImg['type'],array('image/jpeg','image/pjpeg','image/png'))){
  $err_msg  = "只允许上传.png或.jpg图片。请重新<a href='{$uploadpage}'>上传</a>\n";
}

//var_dump($dir.$fileImg['name']);
//echo $err_msg;
//将上传到$_FILES临时 [tmp_name]文件move到其他目录
if(!$err_msg){
  if(!move_uploaded_file($fileImg['tmp_name'],$dir.$fileImg['name'])){
    $err_msg = "移动文件失败，请重新<a href='{$uploadpage}'>上传</a>\n";
  }
}


//打开图片
if($err_msg){
  echo $err_msg;
}else{
  echo "<img src='{$fileImg['name']}' alt='上传的文件' title='上传的文件'/>";
  echo "上传成功,请继续<a href='{$uploadpage}'>上传</a>\n";
}

```

```
switch说明：

UPLOAD_ERR_OK

    Value: 0; There is no error, the file uploaded with success.
UPLOAD_ERR_INI_SIZE

    Value: 1; The uploaded file exceeds the upload_max_filesize directive in php.ini.
UPLOAD_ERR_FORM_SIZE

    Value: 2; The uploaded file exceeds the MAX_FILE_SIZE directive that was specified in the HTML form.
UPLOAD_ERR_PARTIAL

    Value: 3; The uploaded file was only partially uploaded.
UPLOAD_ERR_NO_FILE

    Value: 4; No file was uploaded.
UPLOAD_ERR_NO_TMP_DIR

    Value: 6; Missing a temporary folder. Introduced in PHP 5.0.3.
UPLOAD_ERR_CANT_WRITE

    Value: 7; Failed to write file to disk. Introduced in PHP 5.1.0.
UPLOAD_ERR_EXTENSION

    Value: 8; A PHP extension stopped the file upload. PHP does not provide a way to ascertain which extension caused the file upload to stop; examining the list of loaded extensions with phpinfo() may help. Introduced in PHP 5.2.0.
```

move_uploaded_file()定义和用法,函数将上传的文件移动到新位置,若成功，则返回 true，否则返回 false。
move_uploaded_file(file,newloc)

|语法|描述|
|---|---|
|file|规定要移动的文件|
|newloc|规定文件的新位置|


### HTML表单/按钮

```
<html>
<meta charset="UTF-8"> 
web
//按钮标签
<input type="submit" name="submit" id="submit" value="提交" />
<input type="reset" name="reset1" id="reset1" value="重写" />
<input type="button" name="button1" id="button1" value="按钮" />
//单选按钮和多选按钮
<input type="radio" name="radio1" value="v1" />
<input type="radio" name="radio1" value="v2" />
<input type="checkbox" name="checkbox1" value="c1" />
<input type="checkbox" name="checkbox1" value="c2" />
//下拉框与列表标签,size为可见项目
<select id="select1" name="select1" size="3" multiple="multiple">
  <option value="value1">value1</option>
  <option value="value2">value2</option>
  <option value="value3">value3</option>
</select>
</html>
```


### 同时上传多个文件

```

```